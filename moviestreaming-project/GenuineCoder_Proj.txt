project
================
-->project is related to movies-streaming
-->one micro-service have movies details,another do streaming the movies/vidoes


what used
==============
-->to do this project
1)Api gateway
2)eurka-server
3)zipkin  =>tracing the request life cycle
4)two micro-services(Movie-Catalog-Service,Movie-Streaming-Service)



Eureka-Server creation
=============================
1)go to Spring initializr

2)create a project add dependencies
-------------------------------------------
web,devtools,eureka server,config client(this is for config server)

3)in the main class(annotated with @SpringBootApplication) add
            @EnableEurekaServer
annotation alsothis annotation used for enabling eureka server

4)in application.yml file  
--------------------------------
spring:
  application:
    name: service-registry
server:
  port: 8761
eureka:
  instance:
    hostname: localhost
  client:
    fetch-registry: false
    register-with-eureka: false  #->these two are used for ,actually eureka server also one micro-servive so this should not as act like client to eureka server



5)start the application and hit http://localhost:8761 in the browser then you will get eureka dash board


1)Movie-Catalog-Service
==================================
-->this is one of the micro-service
-->it have movie's information

to develop this-->it is like normal spring boot project
dependecies are
----------------------------
-->lombok,web,eureka discovery client,devtools,jpa,my-sql connector,config client(this is for config server),etc(needed)

1)add @EnableDiscoveryClient in the main cls(annotated with @SpringBootApplication)
2)add below properties in the application.yml file

spring:
  application:
    name: movie-catalog-service
server:
  port: 8091
eureka:
  client:
    server-url:
      defaultZone: http://localhost:8761/eureka


3)remaining code available at(movie-catalog-service project)
4)run it will register in the eureka server




2)Movie-Streaming-Service
================================
-->this is second micro-service
-->it used for stream the vidoes(plays/diplays the vidoes)

to develop this-->it is like normal spring boot project
dependecies are
------------------
-->lombok,web,eureka discovery client,devtools,config client(this is for config server),etc(needed)

-->Cloud LoadBalancer(added recent)(handle load(add this in which service calls another service))



1)1)add @EnableDiscoveryClient in the main cls(annotated with @SpringBootApplication)

spring:
  application:
    name: movie-streaming-service
server:
  port: 8092
eureka:
  client:
    server-url:
      defaultZone: http://localhost:8761/eureka


3)remaining code available at(movie-streaming-service project)
4)run it will register in the eureka server


3)Api Gateway creation
==================================
-->this is api-gateway so it acts as gate to the application
-->so every request go throuth this gateway only
-->for client/user no need to remember all micro-services port number's,etc....
-->we allow to run the all the micro-service by using api-gateway port-number 
-->api-wateway is responsile to route the request to correspondent micro-service

1)add dependencies
--------------------------------------
eureka discovery client,gateway,config client(this is for config server)
2)add below propeties

server:
  port: 8080

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
##this means when the user click movie-info url with using api gateway port number then api-gateways routes correspondent micro-service
##then user/cleint no need to remember microservices portnums's  and servers's
spring:
  cloud:
    gateway:
      mvc:
        routes:
          - id: movie-catalog-service
            uri: http://localhost:8091
            predicates:
              - Path=/movie-info/**
          - id: movie-streaming-service
            uri: http://localhost:8092
            predicates:
              - Path=/movie-stream/**

  application:
    name: api-gateway





How to use RestTemplate
=================================
-->RestTemplate is a class by  using this we can make two or more micro-services communicate each other
-->it  is snchronous
1.create any package (like config) in that create classs->create bean for the RestTemplate
2.use the bean where we need to call another micro-service



Methods in RestTemplate
--------------------------------
1.getForEntity()   => executes a GET request and returns an object of ResponseEntity class,  that contains both the status code and the resource as an object.

2.getForObject()   => similar to getForEntity(), but returns the resource object directly.

3.postForObject()  => creates a new resource using HTTP POST method and returns an entity.

4.postForLocation()  => creates a new resource using the HTTP POST method and returns the location of the newly created resource.

5.delete(url)        => deletes the resource at the specified URL.

6.put(url, request)  =>PUTs the given request object to the URL.



Note=

-->RestTemplate and FegnClient follows Thread-for-request model  means
      ==>When you make an HTTP request using RestTemplate or FeignClient, a thread is created (or borrowed from a thread pool) to handle that request.

-->disadvantage of RestTemplate and FeignClient
    ==>If your application has to handle many concurrent HTTP requests, it will need many threads, 
          each waiting for a response. This can lead to high memory usage and performance degradation

-->how webclient works
   ==>webclient folows event-driven model 
   ==>after we make Http Request then thread initialises the request, means preparing the HTTP request object and sending it over the network.
   ==>then in the webclient the thread is freed up .the thread will not wait for the response,the request responsibility takes WebClient's reactive framework
   ==>the thread do other tasks
   ==>the threads which are availble ,the event loop create task "waiting for response" added in queue
   ==>the event loop continuely checks incoming events,that means if the requested request got reponse then immediatelty event loop hand-overs the response to avaialble 
	thread in the task queue

ex:-
<------------>

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;


@Configuration
/* This class is for configuration of RestTemplate class */

public class RestTemplateConfig {

    /* RestTemplate is a class which allow us to make micro-services communicate each other*/

    @LoadBalanced
    @Bean
    public RestTemplate rest(){
        return new RestTemplate();
    }
}

3.use where we require(call another miro's)

ex:-
<------------>

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

@Component
@Slf4j
/* This class is for call movie-catlog-g-service for this USed RestTemplate*/
public class CallMovieCatalogInfo {

    /* path os movie-catalog-service*/
    public static final String movieCatalogInfoUrl = "http://api-gateway";  //gate-way used here that's why it navige gate-way then gate-way routes correspondent micro
										//we can give direct that micro service name also instead od api-gateway(but gd practice to give api-gateway)
    /*RestTemplate*/
    public final RestTemplate restTemplate;

    public CallMovieCatalogInfo(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }


    /* This method calls movie-catalog-service micro and get path of the movie for display*/
    public String getMoviePath(long movieId) {

        var res = restTemplate.getForEntity(movieCatalogInfoUrl + "/movie-info/getPath/{id}", String.class, movieId);
        log.info("--->getMoviePath is executed and bring path<---" + res.getBody());
        return res.getBody();
    }


 
}



below controller uses above method 
<---------------------------------------->
package com.mvstream.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

@RestController
@Slf4j
@RequestMapping("/movie-stream")

public class MovieStreamingController {

    /* Main directory of the video*/
    public static final String VIDEO_DIRECTORY = "C:\\Users\\Sreenivas Bandaru\\Documents\\Microservices\\";

    public final CallMovieCatalogInfo callMovieCatalogInfo;
    public MovieStreamingController(CallMovieCatalogInfo callMovieCatalogInfo) {
        this.callMovieCatalogInfo = callMovieCatalogInfo;
    }


    /* for diplay or play video in the output */
    @GetMapping("/movie/{path}")
    public ResponseEntity<InputStreamResource> streamVideo(@PathVariable String path) throws FileNotFoundException {
        log.info("-->streamVideo method executed<--");

        File file = new File(VIDEO_DIRECTORY + path);
        if (file.exists()) {
            InputStreamResource inputStreamResource = new InputStreamResource(new FileInputStream(file));
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType("video/mp4"))
                    .body(inputStreamResource);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /* for diplay or play video in the output */
    @GetMapping("/movieWithId/{id}")
    public ResponseEntity<InputStreamResource> streamVideoWithId(@PathVariable long id) throws FileNotFoundException {
        log.info("{MovieId is {}--->"+id);
        String moviePath = callMovieCatalogInfo.getMoviePath(id);
        log.info("Path Is--->{}"+moviePath);
        /* this calls above method along with passing video path */
        return streamVideo(moviePath);


    }

}

---


How to Use WebClient
======================================
-->it  is also like RestTemplate
-->but it is asynchronous and we can make this synchronous also
-->webclient supports Asynchronous and synchrouns also


-->how webclient works
   ==>webclient folows event-driven model 
   ==>after we make Http Request then thread initialises the request, means preparing the HTTP request object and sending it over the network.
   ==>then in the webclient the thread is freed up .the thread will not wait for the response,the request responsibility takes WebClient's reactive framework
   ==>the thread do other tasks
   ==>the threads which are availble ,the event loop create task "waiting for response" added in queue
   ==>the event loop continuely checks incoming events,that means if the requested request got reponse then immediatelty event loop hand-overs the response to avaialble 
	thread in the task queue




1.add webflux dependency

 <!-- for webclient use-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>


2.create package->create class->create bean for webclient

package com.mvstream.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import org.springframework.web.reactive.function.client.WebClient;

@Configuration


public class RestTemplateConfig {

 //the below is for WebClient
    
    @Bean
    @LoadBalanced
    WebClient.Builder createLoadBalancedBuilder() { return WebClient.builder(); }

    @Bean
    WebClient client(WebClient.Builder builder) { return builder.build(); }
     
}

3.call another micro-service using above bean


package com.mvstream.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import org.springframework.web.reactive.function.client.WebClient;

@Component
@Slf4j
/* This class is for call movie-catlog-g-service for this USed WebClient*/
public class CallMovieCatalogInfo {

    /* path os movie-catalog-service*/
    public static final String movieCatalogInfoUrl = "http://api-gateway";



    /* the below is for WebClient */

    public final WebClient webClient;

    public CallMovieCatalogInfo(WebClient webClient) {
        this.webClient = webClient;
    }

    public String getMoviePath(long movieId) {

       return webClient.get()
                .uri(movieCatalogInfoUrl + "/movie-info/getPath/{id}", movieId)
                .retrieve()
                .bodyToMono(String.class)
                .block();

    }

}


below controller uses above method 
<---------------------------------------->
package com.mvstream.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

@RestController
@Slf4j
@RequestMapping("/movie-stream")

public class MovieStreamingController {

    /* Main directory of the video*/
    public static final String VIDEO_DIRECTORY = "C:\\Users\\Sreenivas Bandaru\\Documents\\Microservices\\";

    public final CallMovieCatalogInfo callMovieCatalogInfo;
    public MovieStreamingController(CallMovieCatalogInfo callMovieCatalogInfo) {
        this.callMovieCatalogInfo = callMovieCatalogInfo;
    }


    /* for diplay or play video in the output */
    @GetMapping("/movie/{path}")
    public ResponseEntity<InputStreamResource> streamVideo(@PathVariable String path) throws FileNotFoundException {
        log.info("-->streamVideo method executed<--");

        File file = new File(VIDEO_DIRECTORY + path);
        if (file.exists()) {
            InputStreamResource inputStreamResource = new InputStreamResource(new FileInputStream(file));
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType("video/mp4"))
                    .body(inputStreamResource);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /* for diplay or play video in the output */
    @GetMapping("/movieWithId/{id}")
    public ResponseEntity<InputStreamResource> streamVideoWithId(@PathVariable long id) throws FileNotFoundException {
        log.info("{MovieId is {}--->"+id);
        String moviePath = callMovieCatalogInfo.getMoviePath(id);
        log.info("Path Is--->{}"+moviePath);
        /* this calls above method along with passing video path */
        return streamVideo(moviePath);


    }

}

---





How to use OpenFeign
==================================
-->it is also used for make micro-services communicating each other
-->it is also like RestTemplate and Webcleint
-->used for make micro-services communicate each other
-->When we using the Feign, we have to define only the interfaces and annotate them accordingly
    -->The actual web client implementation is then provided by Spring at runtime
-->by defauly feignclient also synchronous => means, creates a thread for each request and blocks it until it receives a response.

-->To enable the FeignClient in your application you have to mainly specify two things.

     =>@EnableFeignClients : To apply at starter class 
     =>@FeignClient(name=”ApplicationName”) : To define an interface for a Consumer


Note=this openfeign used in doctor-patient-micro-project(twg) not in this project

-->1.add dependecny  and Add @EnableFeignClients annoatation in the main class(annotated with @SpringBootApplication)

	<dependency>
	   <groupId>org.springframework.cloud</groupId>
	   <artifactId>spring-cloud-starter-openfeign</artifactId>
	</dependency>

 
-->2.create an interface with @FeignClient annotation
	
	like :-

	  @FeignClient("patient-registration-service") -->need to mention which micro-service you want send the request
	  public interface Feignclient_Interaface
	  {

	  }
-->3.add method declaration in the interface and annotated with  to which req your sending(patient-registration-service controller whci end point your sending add whole end point url)
	
	like:-

	 @FeignClient("patient-registration-service") -->need to mention which micro-service you want send the request
	  public interface Feignclient_Interaface
	  {
		@GetMapping("/patient/get-patient-by-id/{id}")
		public Patient getPatient(@PathVariable("id") long patientId);   -->create dto package->create class Patient(copy Patient in patient-registration-service service fields into this dto Patient class)
	  }
	  

4.call the method of interface in  the where we want patient details .
 	
	ex:-here i called in the controller where DoctorConsulatation saved time and i just printed the Patient details came from patient-registration-service micro

	@Autowired
	private OpenFeign_interface  openFeign_interface;

	/* save DoctorConsultation */
	@PostMapping("/save-DoctorConsultation")
	public ResponseEntity<DoctorConsultation> saveDoctorConsultation(
			@RequestBody DoctorConsultation doctorConsultation) {
		
		//called the method in  the interface(OpenFeign_interface) for fetching details from another micro
		Patient patientDetails = openFeign_interface.getPatientDetails(doctorConsultation.getPatientId());
		System.out.println(patientDetails);

		DoctorConsultation DoctorConsultation1 = doctorConsultationService.saveConsultation(doctorConsultation);

		if (DoctorConsultation1 != null) {

			return new ResponseEntity<>(DoctorConsultation1, HttpStatus.CREATED);
		} else {
		
			return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);

		}
	}

---



Config Server creattion
============================================
-->it is a centralized configurations controller
-->all the micro-services configurations we put one place (in config server)


depedencies
-------------------
1.confi server
2.eureka discovery cleint   ->this is for register this also in the eureka server


yml file(properties)
--------------------
server:
  port: 8888
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
spring:
  cloud:
    config:
      server:
        native:
          search-location: C:\\config  # -->this means we given configurations in the location
  profiles:
    active: native

apply below in yml (for which micro-service you want to give config-secer)
---------------------------------------------------------------------------------

spring:
  config:
    import: "optional:configserver:http://localhost:8888"  #--->means form this micro-service properties there like that


Note=in our project we given in movie-catalog-service(go and check tha's project)
---



zipkin
===============
-->it is a distributed tracing tool type/feature type
-->distributed tracing means trace the request life-cycle
-->where req started from to where it's going ,like that,and we can identify in which micro req waited/spent more time,and we can find any bottlenecks ,etc...

1.Micrometer used for genarate tracing
2.Zipkin used for view the tracing


step-bystep
------------------------
1.add dependecies
2.install zipkin
3.rest api calls & view tracing info



1.dependencies 
----------------------
-->spring-boot-starter-actuator ==>it gives features for monitor and maintain our-application
-->micro-meter-tracing-bridge-brave  =>maintain tracing info
-->zipkin-reporter-brave              =>used send data of tracing which stored above dependency 


<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-tracing-bridge-brave</artifactId>
</dependency>

<dependency>
    <groupId>io.zipkin.reporter2</groupId>
    <artifactId>zipkin-reporter-brave</artifactId>    
</dependency>


yml file
--------------------
management:
   tracing:
     sampling:
       probability: 1.0


Note= give above dependecies and yml in every micro-service what ever you used(api-gateway,service-registry,doctor-consultation,patient-registration)


2.install zipkin
--------------------------
-->search in google zipkin download(https://zipkin.io/pages/quickstart.html)
-->if you are using java 17b or above then we can download zipkin by using java
quickstart(left side nav bar)
     |
   java
     |
latest release(click this)
     |
it downloaded jar file(open cmd where zipkin jar downloaded folder like downloads)
     |
java -jar zipkin-server-3.4.1-exec.jar   ( use this command(here java -jar zipkin_name.jar)  -->for to start zipkin we have to execute this to see tracing
     |
it will give url ( http://127.0.0.1:9411/) -->execute this in the browser 

     

Note= to see tracing then evry time need to execute zipkin jar file in cmd then it will give url then run the rest-api's and in the browser zipkin click run the query 
      then yo will find tracing
---




















