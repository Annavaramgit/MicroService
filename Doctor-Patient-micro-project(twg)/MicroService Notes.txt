
MicroServices
======================

-->microservices are modern approach in software where by application code devided in small, managable pieces,independent to others.
-->microservices are small small services they work together 
-->microservices are loosely coupled ->( meaning that changes to one service should not affect the other services )
-->it is distributed environment =>not all application code at one place (based on modules devided diff applications)


Monolith Archetecture
===========================
-->Single and large Code Base    => whole code application available at one place
-->Single Stack                  =>every modules in the application developed by one progarmming language(like java)
-->tightly coupled               =>all modules are tightly coupled each other
-->it is centalized environment  =>all application available at one place
-->one time deployement for entire project=> means in the application if single modules got any issue then project not deployed 

MicroServices Communication
====================================
-->one micro service communicates with another microservice
-->there are ways for micro service communication
1)Synchronous 
2)Asyncronous


1)Synchronous 
-----------------
-->it means ,if one micro-service send request to another micro-service 
-->in this, sending micro-service waits for the second micro-service response(blocking)
-->RestTemplate,SpringCloud using communications are Synchronous 

ex:
-----
phone call 
-->we waited untill another person giving the response

2)Asyncronous
---------------
-->it means ,if one micro-service send request to another micro-service 
-->sending microservice will not wait for the second micro service for the response(non-blocking)
-->RabbitMQ,Kafka are the example

ex:
-----
chatting(in whatsapp,etc..)
-->sending person put the message and not wait or stop his work for the response


Micro-service Architecture Components
=======================================================

Note = for architecture diagram search in google spring microservices(https://spring.io/microservices) then you will get official and in that diagram you will find

Api gateway
<============>
-->api gateway acts like gate for microservices
-->means every request go through this gateway only
-->every request come to api-gateway first  and then it will route correspondent micro-service
-->Api Gateway simplifies complexity of client & microservices communication



ConfigServer
<=============>
--> Actually a multiple micro-servives are developed in the micro-service based application
-->each micro-service is a application
-->so each application needs configurations
-->in ConfigServer means all the micro-services confifgurations are maintained here only
-->it is a centralized configurations maintainer
-->if i want change any particular micro-service configurations then no need to go that particular micro-service in configServer we can easily change


Circuit breaker
<=====================>
-->if two micro-services are there(One,Two)
-->if Two micro-service needs One-Microservice data
-->in case if One micro-service fails or not-working
-->that time we need to handle bcz Two-Micro-service don't know One-Micro-service is not working
-->for handling this kind of situation Circuit Breaker need to use

message borker
<===================>
-->apache kafka is a message broker
-->for communication of micro-service this message broker used

ex:zomato app
------------------
-->first order request came to one micro-service 
-->that micro-service intimate to kafka like hey order req came from clinet
-->then after payment micro-service handles payment process 
-->then payment handled micro-service intimate to kafka like either payment =sucess or payment=failure
-->based on kafka message success failure remaing will continue ,etc...


service-regstry
<===================>
-->for communication of micro-services network location is required(servername,portnumber,ect..)
-->instaed of hardcoding the n/w location use eurka server 
-->euraka server is a service-registry and discovery server 
-->when the micro-services running/startup they registed in the euraka server itself then euraka know his n/w location
-->so through this eureka micro-services communicate each other


OpenFeign
=======================
-->it is also like RestTemplate and Webcleint
-->used for make micro-services communicate each other
-->by default it is synchronous 
-->it follows thred-per-request model

how to use openfeign
-----------------------------

-->1.add dependecny  and Add @EnableFeignClients annoatation in the main class(annotated with @SpringBootApplication)

	<dependency>
	   <groupId>org.springframework.cloud</groupId>
	   <artifactId>spring-cloud-starter-openfeign</artifactId>
	</dependency>

 
-->2.create an interface with @FeignClient annotation
	
	like :-

	  @FeignClient("patient-registration-service") -->need to mention which micro-service you want send the request or if you use api-gate-way provovide api-gateway application name
	  public interface Feignclient_Interaface
	  {

	  }

-->3.add method declaration in the interface and annotated with  to which req your sending(patient-registration-service controller which end point your sending add whole end point url)
	
	like:-

	 @FeignClient("patient-registration-service") -->need to mention which micro-service you want send the request
	  public interface Feignclient_Interaface
	  {
		@GetMapping("/patient/get-patient-by-id/{id}")
		public Patient getPatient(@PathVariable("id") long patientId);   -->create dto package->create class Patient(copy Patient in patient-registration-service service fields into this dto Patient class)
	  }
	  

4.call the method of interface in  the where patient details .
 	
	ex:- here i called in the controller where DoctorConsulatation saved time and i just printed the Patient details came from patient-registration-service micro

	@Autowired
	private OpenFeign_interface  openFeign_interface;

	/* save DoctorConsultation */
	@PostMapping("/save-DoctorConsultation")
	public ResponseEntity<DoctorConsultation> saveDoctorConsultation(
			@RequestBody DoctorConsultation doctorConsultation) {
		
		//called the method in  the interface(OpenFeign_interface) for fetching details from another micro
		Patient patientDetails = openFeign_interface.getPatientDetails(doctorConsultation.getPatientId());
		System.out.println(patientDetails);

		DoctorConsultation DoctorConsultation1 = doctorConsultationService.saveConsultation(doctorConsultation);

		if (DoctorConsultation1 != null) {

			return new ResponseEntity<>(DoctorConsultation1, HttpStatus.CREATED);
		} else {
		
			return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);

		}
	}



---



distributed tracing with mico-meter and zipkin
==================================================
-->distributed tracing means trace the request life-cycle
-->where req started from to where it's going ,like that,and we can identify in which micro req waited/spent more time,and we can find any bottlenecks ,etc...

1.Micrometer used for genarate tracing
2.Zipkin used for view the tracing


step-bystep
------------------------
1.add dependecies
2.install zipkin
3.rest api calls & view tracing info



1.dependencies 
----------------------
-->spring-boot-starter-actuator ==>it gives features for monitor and maintain our-application
-->micro-meter-tracing-bridge-brave  =>maintain tracing info
-->zipkin-reporter-brave              =>used send data of tracing which stored above dependency 


<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-tracing-bridge-brave</artifactId>
</dependency>

<dependency>
    <groupId>io.zipkin.reporter2</groupId>
    <artifactId>zipkin-reporter-brave</artifactId>    
</dependency>

yml file
--------------------
management:
   tracing:
     sampling:
       probability: 1.0


Note= give above dependecies and yml in every micro-service what ever you used(api-gateway,service-registry,doctor-consultation,patient-registration)


2.install zipkin
--------------------------
-->search in google zipkin download(https://zipkin.io/pages/quickstart.html)
-->if you are using java 17b or above then we can download zipkin by using java
quickstart(left side nav bar)
     |
   java
     |
latest release(click this)
     |
it downloaded jar file(open cmd where zipkin jar downloaded folder like downloads)
     |
java -jar zipkin-server-3.4.1-exec.jar   ( use this command(here java -jar zipkin_name.jar)  -->for to start zipkin we have to execute this to see tracing
     |
it will give url ( http://127.0.0.1:9411/) -->execute this in the browser 

     

Note= to see tracing then evry time need to execute zipkin jar file in cmd then it will give url then run the rest-api's and in the browser zipkin click run the query 
      then yo will find tracing
---



Circuit breaker
========================
-->circuit breaker means 
-->while micro-services communicating each other if the called micro-service(server) is unable to give response or stopped 
-->then this calling micro-service (client) either need to wait for the response or handle that situation
-->here handling that situation we use circuit breaker
-->in our project we used resilience4j for circuit breaker

(if server micro-service)unable to respond then instead of giving 503 error provide meaning relavent response==>simply means

Circuit Breaker has three states:
------------------------------------------------------
 Closed, Open, and Half_Open

Closed
-------
-->Closed is the initial state of circuit breaker. When microservices run and interact smoothly, circuit breaker is Closed.
(when micro-services comunication is fine then circuit-breaker is on CLOSED state)


Open
---------
-->when called micro(server) not giving response (may be timeout or down) that means failed(503 error came)
-->actually we configured in propertied or yml =>if requests failes 50% then open the circuit breaker
  -->we provide threshold value (like total 4 req ,if 50% req's means 2 req failed then circuit breaker turned into OPEN)



HalfOpen
----------
-->actually in micro-service based applications dwoning server adfter some time working fine is common
  -->not all the time micro-service down
-->so,we also configure is after some time circuitbreaker turned into HALF-BREAKER
  -->HALF-BREAKER means it checks/allows limited requests 
  -->if the that limnited request working fine then circuit breaker turned into CLOSE 
  -->if that limited requests are not working fine then  circuit breaker turned again into OPEN

#below for circuit-breaker yml/properties

resilience4j:
  circuitbreaker:
    instances:
      doctor-service:
        registerHealthIndicator: true
        eventConsumerBufferSize: 10
        failureRateThreshold: 50
        minimumNumberOfCalls: 4  #means after 4 call fail req's circuite breaker tuned on
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s #menas after 5sec circuit breaker tuned into HalfClosed
        permittedNumberOfCallsInHalfOpenState: 2
        slidingWindowSize: 10
        slidingWindowType: COUNT_BASED


1.add dependencies
-----------------------------
<dependency>
<groupId>io.github.resilience4j</groupId>
<artifactId>resilience4j-spring-boot3</artifactId>
<version>2.2.0</version>
</dependency>

<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

Note:-actuator here for to see circuitbreaker status(health of apllication

2.use @circuitbreaker annotation and fallbackmethod 
-------------------------------------------------------------
Like below:-

    @Override
    @CircuitBreaker(name = "doctor-service", fallbackMethod = "circuitBreakerHandler")
    public Patient getPatient(long patientId) {

        Patient patientDetails = openFeign_interface.getPatientDetails(patientId);
        log.info("This is doctor-service service getpateint" + patientDetails);
        return patientDetails;
    }

   /*this is will trigger when server unable to give response ,here i passed null's instead of error*/
    public Patient circuitBreakerHandler(long patientId, Throwable e) {
        log.info("This circuitBreakerHandler");

        Patient patient = new Patient();
        patient.setId(0);
        patient.setName(null);
        patient.setContact(null);
        patient.setDetails(null);
        return patient;

    }
Note=fallbackmethod(circuitBreakerHandler())must have return type of what the end point method have return type(in this example Patient is the return type of both)

3.yml file /properties
-------------------------------
spring:
  application:
    name: movie-streaming-service

server:
  port: 8098
 # port: 0  #dynamically port giving/take at running time (its good pratice)

#below for actuators(we used used in circuit-breaker time)
management:
  health:
    circuitbreakers:
      enabled: true
  endpoints:
    web:
      exposure:
        include: health
  endpoint:
    health:
      show-details: always

#below for circuit-breaker
resilience4j:
  circuitbreaker:
    instances:
      movie-stream:
        registerHealthIndicator: true
        eventConsumerBufferSize: 10
        failureRateThreshold: 50
        minimumNumberOfCalls: 4 #means after 4 call fail req's circuite breaker tuned on
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s #menas after 5sec circuit breaker tuned into HalfClosed
        permittedNumberOfCallsInHalfOpenState: 2
        slidingWindowSize: 10
        slidingWindowType: COUNT_BASED

logging:
  level:
    org.springframework.cloud.netflix.eureka: DEBUG
    org.springframework.cloud.client.loadbalancer: DEBUG

#without this properties also its registering bcz of @EnableDiscoveryClient annotation we used
#if multiple eureka micro's vaialable then we need to give this properties ,bcz ambiguity will come
#eureka:
#  client:
#    server-url:
#      defaultZone: http://localhost:8761/eureka

#the below 4 lines for zipkin tracing pupose
#management:
#  tracing:
#    sampling:
#      probability: 1.0
---